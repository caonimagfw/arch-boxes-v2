#!/bin/bash
# Build virtual machine images (cloud-image focused)

# nounset: "Treat unset variables and parameters [...] as an error when performing parameter expansion."
# errexit: "Exit immediately if [...] command exits with a non-zero status."
set -o nounset -o errexit
shopt -s extglob
readonly DEFAULT_DISK_SIZE="5G"
readonly IMAGE="image.img"
# shellcheck disable=SC2016
readonly MIRROR='https://fastly.mirror.pkgbuild.com/$repo/os/$arch'

function init() {
  readonly ORIG_PWD="${PWD}"
  readonly OUTPUT="${PWD}/output"
  local tmpdir
  tmpdir="$(mktemp --dry-run --directory --tmpdir="${PWD}/tmp")"
  readonly TMPDIR="${tmpdir}"
  mkdir -p "${OUTPUT}" "${TMPDIR}"
  if [ -n "${SUDO_UID:-}" ] && [[ -n "${SUDO_GID:-}" ]]; then
    chown "${SUDO_UID}:${SUDO_GID}" "${OUTPUT}" "${TMPDIR}"
  fi
  cd "${TMPDIR}"

  readonly MOUNT="${PWD}/mount"
  mkdir "${MOUNT}"
}

# Do some cleanup when the script exits
function cleanup() {
  # We want all the commands to run, even if one of them fails.
  set +o errexit
  if [ -n "${LOOPDEV:-}" ]; then
    losetup -d "${LOOPDEV}"
  fi
  if [ -n "${MOUNT:-}" ] && mountpoint -q "${MOUNT}"; then
    # We do not want risking deleting ex: the package cache
    umount --recursive "${MOUNT}" || exit 1
  fi
  if [ -n "${TMPDIR:-}" ]; then
    rm -rf "${TMPDIR}"
  fi
}
trap cleanup EXIT

# Create standard MBR partition table with partition 1 starting at sector 2048.
# This aligns with standard practices and CloudCone's official images.
function setup_disk() {
  truncate -s "${DEFAULT_DISK_SIZE}" "${IMAGE}"

  # Create MBR partition table:
  # Partition 1: start=2048, type=83 (Linux), bootable
  echo 'start=2048, type=83, bootable' | sfdisk "${IMAGE}"

  # Map partition 1 (offset 2048 sectors = 1048576 bytes)
  LOOPDEV=$(losetup --offset 1048576 --find --show "${IMAGE}")

  # Use CloudCone-compatible mke2fs.conf to completely override the build host's
  # default features. This ensures the ext4 filesystem matches CloudCone's
  # Debian 11 images exactly, guaranteeing GRUB 2.02 compatibility.
  # -E hash_alg=half_md4  — match Debian 11 directory hash (GRUB 2.02 compatible)
  # -I 256                — inode size 256 (match Debian 11)
  MKE2FS_CONFIG="${ORIG_PWD}/debian11-mke2fs.conf" mkfs.ext4 -F \
    -E hash_alg=half_md4 \
    -I 256 \
    "${LOOPDEV}"
  mount "${LOOPDEV}" "${MOUNT}"
}

# Install Arch Linux to the filesystem (bootstrap)
function bootstrap() {
  cat <<EOF >pacman.conf
[options]
Architecture = auto
SigLevel = DatabaseOptional

[core]
Include = mirrorlist

[extra]
Include = mirrorlist
EOF
  echo "Server = ${MIRROR}" >mirrorlist

  # We use the hosts package cache
  pacstrap -c -C pacman.conf -K -M "${MOUNT}" base linux grub openssh sudo e2fsprogs qemu-guest-agent
  # Workaround for https://gitlab.archlinux.org/archlinux/arch-install-scripts/-/issues/56
  gpgconf --homedir "${MOUNT}/etc/pacman.d/gnupg" --kill gpg-agent
  cp mirrorlist "${MOUNT}/etc/pacman.d/"
}

# Cleanup the image and trim it
function image_cleanup() {
  # The mkinitcpio autodetect hook removes modules not needed by the
  # running system from the initramfs. This make the image non-bootable
  # on some systems as initramfs lacks the relevant kernel modules.
  # Ex: Some systems need the virtio-scsi kernel module and not the
  # "autodetected" virtio-blk kernel module for disk access.
  #
  # So for the initial install we skip the autodetct hook.
  arch-chroot "${MOUNT}" /usr/bin/mkinitcpio -p linux -- -S autodetect

  # --- Image size reduction: clean caches/logs/docs ---
  # Pacman sync databases (regenerated by `pacman -Sy`)
  rm -rf "${MOUNT}/var/lib/pacman/sync/"*
  # Man pages, documentation, info pages
  rm -rf "${MOUNT}/usr/share/man/"*
  rm -rf "${MOUNT}/usr/share/doc/"*
  rm -rf "${MOUNT}/usr/share/info/"*
  # Build-time logs (journald will create fresh logs on boot)
  rm -rf "${MOUNT}/var/log/journal/"*
  rm -rf "${MOUNT}/var/log/"*.log
  # Temporary files
  rm -rf "${MOUNT}/tmp/"*
  rm -rf "${MOUNT}/var/tmp/"*

  # --- Diagnostics: check linux-firmware size for future optimization ---
  echo "=== [image-size] linux-firmware check ==="
  arch-chroot "${MOUNT}" pacman -Q linux-firmware 2>/dev/null && \
    du -sh "${MOUNT}/usr/lib/firmware/" 2>/dev/null || \
    echo "linux-firmware NOT installed"
  echo "=== [image-size] Largest directories ==="
  du -sh "${MOUNT}/usr/lib/modules/"* "${MOUNT}/usr/lib/firmware/" "${MOUNT}/usr/share/locale/" 2>/dev/null || true

  # Zero-fill free space so zstd compresses efficiently.
  # NOTE: Do NOT use fstrim here. On file-backed loop devices with an offset,
  # fstrim sends DISCARD/PUNCH_HOLE requests that can hit wrong offsets due to
  # kernel loop driver bugs, silently zeroing out live data blocks.
  dd if=/dev/zero of="${MOUNT}/.zerofill" bs=1M 2>/dev/null || true
  rm -f "${MOUNT}/.zerofill"
  sync -f "${MOUNT}/etc/os-release"
}

# Force-disable ext4 features that GRUB 2.02 (CloudCone host) cannot read.
#
# Why: Even though mkfs.ext4 uses our restricted mke2fs.conf, subsequent
# operations (pacstrap, pacman hooks, mkinitcpio, e2fsprogs upgrades, or
# fstrim on offset loop devices) can silently re-enable features like
# dir_index, metadata_csum, 64bit, orphan_file, etc.
# This function is the final safety net — runs on the unmounted device
# right before compression, guaranteeing GRUB 2.02 compatibility.
#
# $1 — raw image file path
function sanitize_ext4() {
  local img="${1}"
  local dev

  dev=$(losetup --offset 1048576 --find --show "${img}")

  echo "=== [ext4-sanitize] Features BEFORE ==="
  tune2fs -l "${dev}" 2>/dev/null | grep -iE "features|Filesystem revision|extra isize|hash"

  # Disable features NOT present in CloudCone's Debian 11 reference image.
  # Keep dir_index (Debian 11 has it, GRUB 2.02 reads it with half_md4 hash).
  # ^metadata_csum    — checksummed metadata unsupported by GRUB 2.02
  # ^metadata_csum_seed — seed variant of above
  # ^64bit            — 64-bit block addressing unsupported by GRUB 2.02
  # ^orphan_file      — e2fsprogs ≥1.47 feature, not in Debian 11
  # ^large_dir        — not in Debian 11
  tune2fs -O ^metadata_csum,^metadata_csum_seed,^64bit,^orphan_file,^large_dir \
    "${dev}" 2>/dev/null || true

  # Force extra_isize=28 and hash_alg=half_md4 to match Debian 11 exactly.
  tune2fs -E hash_alg=half_md4 "${dev}" 2>/dev/null || true

  # Fix any inconsistencies.
  e2fsck -fy "${dev}" 2>/dev/null || true

  echo "=== [ext4-sanitize] Features AFTER ==="
  tune2fs -l "${dev}" 2>/dev/null | grep -iE "features|Filesystem revision|extra isize|hash"

  losetup -d "${dev}"
}

# Mount image helper (loop device + mount) — partition 1 offset
function mount_image() {
  # Mount partition 1 (offset 2048 sectors = 1048576 bytes)
  LOOPDEV=$(losetup --offset 1048576 --find --show "${1:-${IMAGE}}")
  mount "${LOOPDEV}" "${MOUNT}"
  # Setup bind mount to package cache
  mount --bind "/var/cache/pacman/pkg" "${MOUNT}/var/cache/pacman/pkg"
}

# Unmount image helper (umount + detach loop device)
function unmount_image() {
  umount --recursive "${MOUNT}"
  losetup -d "${LOOPDEV}"
  LOOPDEV=""
}


# Compute SHA256, adjust owner to $SUDO_UID:$SUDO_UID and move to output/
function mv_to_output() {
  local artifact tar_zst
  local -a artifacts

  artifacts=("${1}")
  sha256sum "${1}" >"${1}.SHA256"
  artifacts+=("${1}.SHA256")

  if [ -f "${1}.zst" ]; then
    sha256sum "${1}.zst" >"${1}.zst.SHA256"
    artifacts+=("${1}.zst" "${1}.zst.SHA256")
  fi

  tar_zst="${1%.raw}.tar.zst"
  if [ -f "${tar_zst}" ]; then
    sha256sum "${tar_zst}" >"${tar_zst}.SHA256"
    artifacts+=("${tar_zst}" "${tar_zst}.SHA256")
  fi

  if [ -n "${SUDO_UID:-}" ]; then
    chown "${SUDO_UID}:${SUDO_GID}" "${artifacts[@]}"
  fi
  for artifact in "${artifacts[@]}"; do
    mv "${artifact}" "${OUTPUT}/"
  done
}

# Helper function: create a new image from the "base" image
# ${1} - final file
# ${2} - pre
# ${3} - post
function create_image() {
  local tmp_image
  tmp_image="$(basename "$(mktemp -u)")"
  cp -a "${IMAGE}" "${tmp_image}"
  if [ -n "${DISK_SIZE}" ]; then
    truncate -s "${DISK_SIZE}" "${tmp_image}"
  fi
  mount_image "${tmp_image}"
  if [ -n "${DISK_SIZE}" ]; then
    resize2fs "${LOOPDEV}"
  fi

  if [ 0 -lt "${#PACKAGES[@]}" ]; then
    arch-chroot "${MOUNT}" /usr/bin/pacman -S --noconfirm "${PACKAGES[@]}"
  fi
  if [ 0 -lt "${#SERVICES[@]}" ]; then
    arch-chroot "${MOUNT}" /usr/bin/systemctl enable "${SERVICES[@]}"
  fi
  "${2}"
  image_cleanup
  unmount_image
  sanitize_ext4 "${tmp_image}"
  "${3}" "${tmp_image}" "${1}"
  mv_to_output "${1}"
}

# ${1} - Optional build version. If not set, will generate a default based on date.
function main() {
  if [ "$(id -u)" -ne 0 ]; then
    echo "root is required"
    exit 1
  fi

  if ! command -v tar >/dev/null 2>&1 || ! command -v zstd >/dev/null 2>&1; then
    echo "Required tools missing: tar and zstd must be installed on the build host."
    exit 1
  fi

  init

  setup_disk
  bootstrap
  # shellcheck source=images/base.sh
  source "${ORIG_PWD}/images/base.sh"
  pre
  unmount_image
  sanitize_ext4 "${IMAGE}"

  local build_version
  if [ -z "${1:-}" ]; then
    build_version="$(date +%Y%m%d).0"
    echo "WARNING: BUILD_VERSION wasn't set!"
    echo "Falling back to $build_version"
  else
    build_version="${1}"
  fi

  local image_filter image_count
  image_filter="${IMAGE_FILTER:-cloud-image.sh}"
  image_count=0
  for image in "${ORIG_PWD}/images/"!(base).sh; do
    if [[ ! "$(basename "${image}")" == ${image_filter} ]]; then
      continue
    fi
    # shellcheck source=/dev/null
    source "${image}"
    create_image "${IMAGE_NAME}" pre post
    image_count=$((image_count + 1))
  done

  if [ "${image_count}" -eq 0 ]; then
    echo "No image matched IMAGE_FILTER='${image_filter}'"
    exit 1
  fi
}
main "$@"
