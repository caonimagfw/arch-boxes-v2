#!/bin/bash
# Build virtual machine images (cloud-image focused)

# nounset: "Treat unset variables and parameters [...] as an error when performing parameter expansion."
# errexit: "Exit immediately if [...] command exits with a non-zero status."
set -o nounset -o errexit
shopt -s extglob
readonly DEFAULT_DISK_SIZE="5G"
readonly IMAGE="image.img"
# shellcheck disable=SC2016
readonly MIRROR='https://fastly.mirror.pkgbuild.com/$repo/os/$arch'

function init() {
  readonly ORIG_PWD="${PWD}"
  readonly OUTPUT="${PWD}/output"
  local tmpdir
  tmpdir="$(mktemp --dry-run --directory --tmpdir="${PWD}/tmp")"
  readonly TMPDIR="${tmpdir}"
  mkdir -p "${OUTPUT}" "${TMPDIR}"
  if [ -n "${SUDO_UID:-}" ] && [[ -n "${SUDO_GID:-}" ]]; then
    chown "${SUDO_UID}:${SUDO_GID}" "${OUTPUT}" "${TMPDIR}"
  fi
  cd "${TMPDIR}"

  readonly MOUNT="${PWD}/mount"
  mkdir "${MOUNT}"
}

# Do some cleanup when the script exits
function cleanup() {
  # We want all the commands to run, even if one of them fails.
  set +o errexit
  if [ -n "${LOOPDEV:-}" ]; then
    losetup -d "${LOOPDEV}"
  fi
  if [ -n "${MOUNT:-}" ] && mountpoint -q "${MOUNT}"; then
    # We do not want risking deleting ex: the package cache
    umount --recursive "${MOUNT}" || exit 1
  fi
  if [ -n "${TMPDIR:-}" ]; then
    rm -rf "${TMPDIR}"
  fi
}
trap cleanup EXIT

# Create the disk image as a "superfloppy" — ext4 starting at byte 0,
# no partition table during build.  After unmount we inject a fake MBR
# so CloudCone host GRUB can address it as (hd0,msdos1).
#
# Why: host GRUB 2.02's ext2 module can traverse ext4 directories when
# the filesystem starts at byte 0 (proven with superfloppy), but garbles
# directory listings when the filesystem sits behind a real 1 MiB partition
# offset.  The fake-MBR trick sets partition 1 LBA-start = 0, so GRUB
# resolves (hd0,msdos1) to byte 0 — identical to (hd0).
function setup_disk() {
  truncate -s "${DEFAULT_DISK_SIZE}" "${IMAGE}"

  LOOPDEV=$(losetup --find --show "${IMAGE}")
  # Use Debian 11 mke2fs.conf so the ext4 filesystem matches what CloudCone's
  # host GRUB can read (no metadata_csum_seed / orphan_file incompat features).
  MKE2FS_CONFIG="${ORIG_PWD}/debian11-mke2fs.conf" mkfs.ext4 -F "${LOOPDEV}"
  mount "${LOOPDEV}" "${MOUNT}"
}

# Install Arch Linux to the filesystem (bootstrap)
function bootstrap() {
  cat <<EOF >pacman.conf
[options]
Architecture = auto
SigLevel = DatabaseOptional

[core]
Include = mirrorlist

[extra]
Include = mirrorlist
EOF
  echo "Server = ${MIRROR}" >mirrorlist

  # We use the hosts package cache
  pacstrap -c -C pacman.conf -K -M "${MOUNT}" base linux grub openssh sudo e2fsprogs qemu-guest-agent
  # Workaround for https://gitlab.archlinux.org/archlinux/arch-install-scripts/-/issues/56
  gpgconf --homedir "${MOUNT}/etc/pacman.d/gnupg" --kill gpg-agent
  cp mirrorlist "${MOUNT}/etc/pacman.d/"
}

# Cleanup the image and trim it
function image_cleanup() {
  # Remove pacman key ring for re-initialization
  rm -rf "${MOUNT}/etc/pacman.d/gnupg/"

  # The mkinitcpio autodetect hook removes modules not needed by the
  # running system from the initramfs. This make the image non-bootable
  # on some systems as initramfs lacks the relevant kernel modules.
  # Ex: Some systems need the virtio-scsi kernel module and not the
  # "autodetected" virtio-blk kernel module for disk access.
  #
  # So for the initial install we skip the autodetct hook.
  arch-chroot "${MOUNT}" /usr/bin/mkinitcpio -p linux -- -S autodetect

  # --- Image size reduction: clean caches/logs/docs ---
  # Pacman sync databases (regenerated by `pacman -Sy`)
  rm -rf "${MOUNT}/var/lib/pacman/sync/"*
  # Man pages, documentation, info pages
  rm -rf "${MOUNT}/usr/share/man/"*
  rm -rf "${MOUNT}/usr/share/doc/"*
  rm -rf "${MOUNT}/usr/share/info/"*
  # Build-time logs (journald will create fresh logs on boot)
  rm -rf "${MOUNT}/var/log/journal/"*
  rm -rf "${MOUNT}/var/log/"*.log
  # Temporary files
  rm -rf "${MOUNT}/tmp/"*
  rm -rf "${MOUNT}/var/tmp/"*

  # --- Diagnostics: check linux-firmware size for future optimization ---
  echo "=== [image-size] linux-firmware check ==="
  arch-chroot "${MOUNT}" pacman -Q linux-firmware 2>/dev/null && \
    du -sh "${MOUNT}/usr/lib/firmware/" 2>/dev/null || \
    echo "linux-firmware NOT installed"
  echo "=== [image-size] Largest directories ==="
  du -sh "${MOUNT}/usr/lib/modules/"* "${MOUNT}/usr/lib/firmware/" "${MOUNT}/usr/share/locale/" 2>/dev/null || true

  sync -f "${MOUNT}/etc/os-release"
  fstrim --verbose "${MOUNT}"
}

# Mount image helper (loop device + mount) — superfloppy, no partitions
function mount_image() {
  LOOPDEV=$(losetup --find --show "${1:-${IMAGE}}")
  mount "${LOOPDEV}" "${MOUNT}"
  # Setup bind mount to package cache
  mount --bind "/var/cache/pacman/pkg" "${MOUNT}/var/cache/pacman/pkg"
}

# Unmount image helper (umount + detach loop device)
function unmount_image() {
  umount --recursive "${MOUNT}"
  losetup -d "${LOOPDEV}"
  LOOPDEV=""
}

# Inject a minimal MBR partition table into a superfloppy image.
# Partition 1 starts at LBA 0 and spans the entire image.
#
# This lets CloudCone host GRUB address the disk as (hd0,msdos1) while
# the ext4 filesystem still begins at byte 0 (where GRUB 2.02 can read
# it without garbling directory listings).
#
# Safety: ext4's "boot block" (bytes 0-1023) is reserved / unused by the
# filesystem.  The superblock lives at byte 1024.  Writing a 66-byte MBR
# structure at offsets 446-511 is harmless.
#
# On the VPS the Linux kernel detects the MBR and exposes /dev/vda1,
# so root=/dev/vda1 and fstab entries work as expected.
function inject_mbr() {
  local image="${1}"
  local total_bytes total_sectors
  total_bytes=$(stat -c %s "${image}")
  total_sectors=$(( total_bytes / 512 ))

  # Little-endian bytes of total_sectors (4 bytes)
  local s0 s1 s2 s3
  s0=$(printf '%02x' $(( total_sectors & 0xFF )))
  s1=$(printf '%02x' $(( (total_sectors >> 8)  & 0xFF )))
  s2=$(printf '%02x' $(( (total_sectors >> 16) & 0xFF )))
  s3=$(printf '%02x' $(( (total_sectors >> 24) & 0xFF )))

  # 16-byte partition entry at offset 446:
  #   80           = bootable
  #   00 01 00     = CHS start (head 0, sector 1, cylinder 0)
  #   83           = Linux partition type
  #   FE FF FF     = CHS end   (LBA-mode max)
  #   00 00 00 00  = LBA start = 0
  #   s0 s1 s2 s3  = LBA size  = total_sectors
  printf '\x80\x00\x01\x00\x83\xfe\xff\xff\x00\x00\x00\x00\x'"${s0}"'\x'"${s1}"'\x'"${s2}"'\x'"${s3}" | \
    dd of="${image}" bs=1 seek=446 conv=notrunc status=none

  # MBR boot signature
  printf '\x55\xaa' | dd of="${image}" bs=1 seek=510 conv=notrunc status=none

  echo "MBR injected: partition 1 @ LBA 0, ${total_sectors} sectors ($(( total_bytes / 1024 / 1024 )) MiB)"
}

# Compute SHA256, adjust owner to $SUDO_UID:$SUDO_UID and move to output/
function mv_to_output() {
  local artifact tar_zst
  local -a artifacts

  artifacts=("${1}")
  sha256sum "${1}" >"${1}.SHA256"
  artifacts+=("${1}.SHA256")

  if [ -f "${1}.zst" ]; then
    sha256sum "${1}.zst" >"${1}.zst.SHA256"
    artifacts+=("${1}.zst" "${1}.zst.SHA256")
  fi

  tar_zst="${1%.raw}.tar.zst"
  if [ -f "${tar_zst}" ]; then
    sha256sum "${tar_zst}" >"${tar_zst}.SHA256"
    artifacts+=("${tar_zst}" "${tar_zst}.SHA256")
  fi

  if [ -n "${SUDO_UID:-}" ]; then
    chown "${SUDO_UID}:${SUDO_GID}" "${artifacts[@]}"
  fi
  for artifact in "${artifacts[@]}"; do
    mv "${artifact}" "${OUTPUT}/"
  done
}

# Helper function: create a new image from the "base" image
# ${1} - final file
# ${2} - pre
# ${3} - post
function create_image() {
  local tmp_image
  tmp_image="$(basename "$(mktemp -u)")"
  cp -a "${IMAGE}" "${tmp_image}"
  if [ -n "${DISK_SIZE}" ]; then
    truncate -s "${DISK_SIZE}" "${tmp_image}"
  fi
  mount_image "${tmp_image}"
  if [ -n "${DISK_SIZE}" ]; then
    resize2fs "${LOOPDEV}"
  fi

  if [ 0 -lt "${#PACKAGES[@]}" ]; then
    arch-chroot "${MOUNT}" /usr/bin/pacman -S --noconfirm "${PACKAGES[@]}"
  fi
  if [ 0 -lt "${#SERVICES[@]}" ]; then
    arch-chroot "${MOUNT}" /usr/bin/systemctl enable "${SERVICES[@]}"
  fi
  "${2}"
  image_cleanup
  unmount_image
  inject_mbr "${tmp_image}"
  "${3}" "${tmp_image}" "${1}"
  mv_to_output "${1}"
}

# ${1} - Optional build version. If not set, will generate a default based on date.
function main() {
  if [ "$(id -u)" -ne 0 ]; then
    echo "root is required"
    exit 1
  fi

  if ! command -v tar >/dev/null 2>&1 || ! command -v zstd >/dev/null 2>&1; then
    echo "Required tools missing: tar and zstd must be installed on the build host."
    exit 1
  fi

  init

  setup_disk
  bootstrap
  # shellcheck source=images/base.sh
  source "${ORIG_PWD}/images/base.sh"
  pre
  unmount_image

  local build_version
  if [ -z "${1:-}" ]; then
    build_version="$(date +%Y%m%d).0"
    echo "WARNING: BUILD_VERSION wasn't set!"
    echo "Falling back to $build_version"
  else
    build_version="${1}"
  fi

  # Parse optional disk size from version suffix (e.g. "6.18.9.18G" -> "18G")
  local version_disk_size=""
  if [[ "${build_version}" =~ \.([0-9]+[Gg])$ ]]; then
    version_disk_size="${BASH_REMATCH[1]^^}"
    echo "Detected disk size from version suffix: ${version_disk_size}"
  fi

  local image_filter image_count
  image_filter="${IMAGE_FILTER:-cloud-image.sh}"
  image_count=0
  for image in "${ORIG_PWD}/images/"!(base).sh; do
    if [[ ! "$(basename "${image}")" == ${image_filter} ]]; then
      continue
    fi
    # shellcheck source=/dev/null
    source "${image}"
    if [ -n "${version_disk_size}" ]; then
      DISK_SIZE="${version_disk_size}"
    fi
    create_image "${IMAGE_NAME}" pre post
    image_count=$((image_count + 1))
  done

  if [ "${image_count}" -eq 0 ]; then
    echo "No image matched IMAGE_FILTER='${image_filter}'"
    exit 1
  fi
}
main "$@"
